<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>連接線動畫</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>節點連線動畫</title>
    <style>
        body {
            background: #fff;
            margin: 0;
            overflow: hidden;
        }
        svg {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .node {
            stroke: none;
        }
        #panel {
            position: fixed;
            top: 20px;
            right: 20px;
            left: auto;
            background: rgba(255,255,255,0.95);
            border-radius: 10px;
            box-shadow: 0 2px 8px #0002;
            padding: 16px 20px 10px 20px;
            z-index: 10;
            font-family: sans-serif;
            font-size: 15px;
            color: #333;
            user-select: none;
        }
        #panel label {
            display: block;
            margin-bottom: 8px;
        }
        #panel input[type=range] {
            width: 120px;
            vertical-align: middle;
        }
        #panel .row {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
<div id="panel">
    <div class="row">
        <label>線條粗細：<input id="widthSlider" type="range" min="1" max="12" value="4"> <span id="widthVal">4</span> px</label>
    </div>
    <div class="row">
        <label>顏色深淺：<input id="colorSlider" type="range" min="0" max="100" value="60"> <span id="colorVal">60</span> %</label>
    </div>
    <div class="row">
        <label>流速：<input id="speedSlider" type="range" min="1" max="30" value="10"> <span id="speedVal">10</span> x</label>
    </div>
</div>
<svg id="network" width="100vw" height="100vh"></svg>
<script>
// 幾個節點座標
const nodes = [
    {x: 200, y: 200, color: '#ffb347'},
    {x: 400, y: 180, color: '#4f9d69'},
    {x: 300, y: 350, color: '#3b6ea5'},
    {x: 500, y: 320, color: '#e94f37'},
    {x: 600, y: 200, color: '#f6c915'}, // 右邊黃點 index 4
    // 新增5個點
    {x: 650, y: 100, color: '#3b6ea5'},
    {x: 670, y: 160, color: '#4f9d69'},
    {x: 670, y: 240, color: '#e94f37'},
    {x: 650, y: 300, color: '#ffb347'},
    {x: 630, y: 200, color: '#4f9d69'}
];
// 連線對 (index)
const links = [
    [0,1], [1,2], [2,3], [3,4], [0,2], [1,4],
    // 新增5個點都連到最右邊黃點（index 4）
    [5,4], [6,4], [7,4], [8,4], [9,4]
];

const svg = document.getElementById('network');

// 畫線 (灰色漸層)
const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
svg.appendChild(defs);

links.forEach((link, i) => {
    const [a, b] = link;
    // 動態漸層 id
    const gradId = `grad${i}`;
    const grad = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
    grad.setAttribute('id', gradId);
    grad.setAttribute('gradientUnits', 'userSpaceOnUse');
    grad.setAttribute('x1', nodes[a].x);
    grad.setAttribute('y1', nodes[a].y);
    grad.setAttribute('x2', nodes[b].x);
    grad.setAttribute('y2', nodes[b].y);
    grad.innerHTML = `
        <stop offset="0%" stop-color="#bbb">"></stop>
        <stop offset="100%" stop-color="#eee">"></stop>
    `;
    defs.appendChild(grad);
});

const NODE_RADIUS = 10;
let lineWidth = 4;
let colorDepth = 60; // 0~100, 0最淺 100最深
let flowSpeed = 0.1; // 0.01~0.3
function getEdgePoint(x1, y1, x2, y2, r) {
    // 從(x1,y1)往(x2,y2)方向，距離r的點
    const dx = x2 - x1;
    const dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len === 0) return {x: x1, y: y1};
    return {
        x: x1 + dx * r / len,
        y: y1 + dy * r / len
    };
}
const lineEls = links.map((link, i) => {
    const [a, b] = link;
    const p1 = getEdgePoint(nodes[a].x, nodes[a].y, nodes[b].x, nodes[b].y, NODE_RADIUS);
    const p2 = getEdgePoint(nodes[b].x, nodes[b].y, nodes[a].x, nodes[a].y, NODE_RADIUS);
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', p1.x);
    line.setAttribute('y1', p1.y);
    line.setAttribute('x2', p2.x);
    line.setAttribute('y2', p2.y);
    line.setAttribute('stroke', `url(#grad${i})`);
    line.setAttribute('stroke-width', lineWidth);
    line.setAttribute('opacity', '0.8');
    return line;
});

// 畫節點
nodes.forEach((node) => {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', 10);
    circle.setAttribute('fill', node.color);
    circle.setAttribute('class', 'node');
    svg.appendChild(circle);
});

// 動畫：讓漸層在連線上流動
let t = 0;
function animate() {
    t += flowSpeed;
    links.forEach((link, i) => {
        const grad = defs.children[i];
        // 顏色深淺調整
        const dark = 180 - colorDepth; // 180~80
        const mid = 120 - colorDepth * 0.7; // 120~50
        const light = 220 - colorDepth * 0.5; // 220~170
        // 動態調整漸層 stop offset
        const offset = (Math.sin(t + i) + 1) / 2 * 60 + 20; // 20~80%
        grad.innerHTML = `
            <stop offset="0%" stop-color="rgb(${dark},${dark},${dark})"></stop>
            <stop offset="${offset}%" stop-color="rgb(${mid},${mid},${mid})"></stop>
            <stop offset="100%" stop-color="rgb(${light},${light},${light})"></stop>
        `;
        // 線條粗細
        lineEls[i].setAttribute('stroke-width', lineWidth);
    });
    requestAnimationFrame(animate);
}
animate();

// 控制面板事件
const widthSlider = document.getElementById('widthSlider');
const colorSlider = document.getElementById('colorSlider');
const speedSlider = document.getElementById('speedSlider');
const widthVal = document.getElementById('widthVal');
const colorVal = document.getElementById('colorVal');
const speedVal = document.getElementById('speedVal');

widthSlider.addEventListener('input', e => {
    lineWidth = +widthSlider.value;
    widthVal.textContent = lineWidth;
});
colorSlider.addEventListener('input', e => {
    colorDepth = +colorSlider.value;
    colorVal.textContent = colorDepth;
});
speedSlider.addEventListener('input', e => {
    flowSpeed = +speedSlider.value / 100;
    speedVal.textContent = speedSlider.value;
});
</script>
</body>
</html>
     
    </style>
</head>
<body>
    <div class="container">
        <!-- 線條 E-F：灰色流動 -->
        <div class="line-section">
            <canvas id="canvas-ef" width="800" height="100"></canvas>
        </div>
    </div>

    <script>
        /**
         * Canvas 繪製函數：動態流動漸層連線（灰色版本）
         * 使用 requestAnimationFrame 創造平滑的位移動畫
         */
        function drawFlowingConnection(canvasId, sourceX, sourceY, targetX, targetY, options = {}) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            
            // 畫節點（確保節點在所有線的上層）
            const nodeEls = [];
            nodes.forEach((node) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', node.x);
                circle.setAttribute('cy', node.y);
                circle.setAttribute('r', 10);
                circle.setAttribute('fill', node.color);
                circle.setAttribute('class', 'node');
                nodeEls.push(circle);
            });
            // 先畫線再畫節點，確保節點在上層
            lineEls.forEach(line => svg.appendChild(line));
            nodeEls.forEach(circle => svg.appendChild(circle));
            const controlX = (sourceX + targetX) / 2;
            const controlY = pathType === 'bezier' ? sourceY - 20 : sourceY;
            
            function animate() {
                // 清除畫布
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 繪製背景線（灰色）
                ctx.strokeStyle = '#666666';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.3;
                ctx.beginPath();
                ctx.moveTo(sourceX, sourceY);
                if (pathType === 'bezier') {
                    ctx.quadraticCurveTo(controlX, controlY, targetX, targetY);
                } else {
                    ctx.lineTo(targetX, targetY);
                }
                ctx.stroke();
                
                // 繪製發光層（灰色）
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = glowWidth;
                ctx.globalAlpha = 0.15;
                ctx.filter = 'blur(12px)';
                ctx.beginPath();
                ctx.moveTo(sourceX, sourceY);
                if (pathType === 'bezier') {
                    ctx.quadraticCurveTo(controlX, controlY, targetX, targetY);
                } else {
                    ctx.lineTo(targetX, targetY);
                }
                ctx.stroke();
                ctx.filter = 'none';
                
                // 創建流動漸層
                const lineLength = Math.sqrt(Math.pow(targetX - sourceX, 2) + Math.pow(targetY - sourceY, 2));
                const angle = Math.atan2(targetY - sourceY, targetX - sourceX);
                
                // 創建多段漸層以實現重複效果
                ctx.save();
                ctx.translate(sourceX, sourceY);
                ctx.rotate(angle);
                
                // 使用漸層
                const gradient = ctx.createLinearGradient(-offset % gradientRepeatLength, 0, lineLength, 0);
                
                // 計算需要多少個漸層循環
                const cycles = Math.ceil((lineLength + gradientRepeatLength) / gradientRepeatLength);
                
                for (let i = -1; i < cycles; i++) {
                    const basePos = (i * gradientRepeatLength - offset % gradientRepeatLength) / lineLength;
                    const cycleLength = gradientRepeatLength / lineLength;
                    
                    if (basePos < 1 && basePos + cycleLength > 0) {
                        // 創建循環漸層：深灰 → 淺灰 → 深灰，確保無縫銜接
                        gradient.addColorStop(Math.max(0, basePos), '#444444');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.1)), '#555555');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.2)), '#666666');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.3)), '#777777');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.4)), '#888888');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.5)), '#aaaaaa'); // 中心點為淺灰
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.6)), '#888888');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.7)), '#777777');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.8)), '#666666');
                        gradient.addColorStop(Math.max(0, Math.min(1, basePos + cycleLength * 0.9)), '#555555');
                        gradient.addColorStop(Math.min(1, basePos + cycleLength), '#444444'); // 回到深灰，無縫循環
                    }
                }
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.globalAlpha = 1;
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(lineLength, 0);
                ctx.stroke();
                
                ctx.restore();
                
                // 更新偏移量
                offset += speed;
                if (offset >= gradientRepeatLength) {
                    offset = 0;
                }
                
                // 下一幀
                requestAnimationFrame(animate);
            }
            
            // 啟動動畫
            animate();
        }
        
        // 初始化 Canvas 動畫（第三條線，灰色）
        drawFlowingConnection('canvas-ef', 100, 50, 700, 50, {
            speed: 0.3,
            lineWidth: 4,
            glowWidth: 8,
            gradientLength: 200,
            pathType: 'straight',
            label: ['E', 'F']
        });
    </script>
</body>
</html>

